<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CPG_for_Unstructured_Terrain</title>
      <link href="/2022/09/12/CPG-for-unstructured-terrain/"/>
      <url>/2022/09/12/CPG-for-unstructured-terrain/</url>
      
        <content type="html"><![CDATA[<blockquote><p>reference: Central pattern generator with inertial feedback for stable locomotion and climbing in unstructured terrain</p></blockquote><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>Incorporating sensory feedback for gait adaptation in CPG models can improve the locomotive performance of robots in challenging terrain. In this paper, we present a novel approach for incorporating inertial feedback into the CPG framework for locomotion on steep, unstructured terrain. That is, we adapt the limit cycle of each leg of the robot to produce locomotion and posture control. The control frame is validated on a hexapod robot to walk in a variety of steep, challenging terrains.<br><span id="more"></span></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>This paper presents a new method to incorporate inertial feedback into bio-inspired CPG in order to implement reactive posture correction directly as part of the locomotion. Usually, CPGs do not rely on sensory inputs to produce locomotive outputs, but the outputs are adapted based on environmental information. Namely, sensory input is used to adapt the gait produced by the CPG by inhibiting or extenuating certain gait characteristics. A handful of recent works have implemented closed-loop CPG implementations based on various sensory feedback. However, CPG-based modeling still lacks generic methodologies for integrating sensory feedback to adapt the locomotion.</p><p>In this paper, we present a method for adapting CPG based on inertial feedback to make CoG positioned more centrally within the support polygon. </p><h1 id="CPG-Modeling"><a href="#CPG-Modeling" class="headerlink" title="CPG Modeling"></a>CPG Modeling</h1><p>The model is:</p><script type="math/tex; mode=display">\left\{\begin{aligned}\dot{x}_{i}(t)=&-\omega \cdot y_{i}(t)+\gamma\left(\mu^{2}-\sqrt{x_{i}(t)^{2}+y_{i}(t)^{2}}\right) \cdot x_{i}(t) \\\dot{y}_{i}(t)=&+\omega \cdot x_{i}(t)+\gamma\left(\mu^{2}-\sqrt{x_{i}(t)^{2}+y_{i}(t)^{2}}\right) \cdot y_{i}(t) \\&+\left(\lambda \sum_{j} K_{i j} y_{j}(t)\right)\end{aligned}\right. \tag{1}</script><p>where $\mu$ defines the radius of the limit cycle,$\omega$ defines the angular frequency of oscillation, $\gamma$ defines the forcing to the limit cycle, $\lambda$ defines the coupling strength and K defines the gait by setting the phase relationship between legs.</p><p>In CPGs, the limit cycle defines a closed path in the joint space, which leads to the trajectory of the robots’ end-effectors. In this work, the limit cycle is in the shape of superellipse, which reads:</p><script type="math/tex; mode=display">H(x, y)=\left|\frac{x}{a}\right|^{d}+\left|\frac{y}{b}\right|^{d}\tag{2}</script><p>When d =2, H is an elliptic limit cycle, whereas $d&gt;2$ provides a more rectangular limit cycle as d increases. In general, the choice of $d$ should be guided by the type of terrain the robot will evolve in: $d=2$ seems to allow quick and stable locomotion on flat ground, whereas $d=4$ seems better suited for rough or inclined terrain. The following figure compares $d=2$ and $d=4$.</p><p><img src="/images/limit_cycle.png" alt></p><p>Then the CPG model can employ the new limit cycle $H(x,y)$ and obtain:</p><script type="math/tex; mode=display">\left\{\begin{aligned}\dot{x_{i}}(t)=&-\omega \cdot \partial H_{y_{i}}+\gamma\left(1-H\left(x_{i}(t), y_{i}(t)\right)\right) \cdot \partial H_{x_{i}} \\\dot{y}_{i}(t)=&+\omega \cdot \partial H_{x_{i}}+\gamma\left(1-H\left(x_{i}(t), y_{i}(t)\right)\right) \cdot \partial H_{y_{i}} \\&+\left(\lambda \sum_{j} K_{i j} y_{j}(t)\right)\end{aligned}\right.\tag{3}</script><p>Where in this case, $\omega$ does not directly translate to the gait period, instead linearly linked to the gait period.</p><p>In order to  incorporate inertial inertial feedback for body control, we consider offsets $c_x$ and $c_y$ as the center of the limit cycle by defining:</p><script type="math/tex; mode=display">H_{c}(x, y)=\left|\frac{x-c_{x}}{a}\right|^{n}+\left|\frac{y-c_{y}}{b}\right|^{n}\tag{4}</script><p>Finally as i denotes the $i$ th leg, we can get the following modified CPG equations:</p><script type="math/tex; mode=display">\left\{\begin{aligned}\dot{x}_{i}(t)=&-\omega \cdot \partial H_{y_{i}}+\gamma\left(1-H_{c_{i}}\left(x_{i}(t), y_{i}(t)\right)\right) \cdot \partial H_{x_{i}} \\\dot{y}_{i}(t)=&+\omega \cdot \partial H_{x_{i}}+\gamma\left(1-H_{c_{i}}\left(x_{i}(t), y_{i}(t)\right)\right) \cdot \partial H_{y_{i}} \\&+\left(\lambda \sum_{j} K_{i j}\left(y_{j}(t)-c_{y, j}\right)\right.\end{aligned}\right.\tag{5}</script><p>With $\partial H_{\zeta}=\frac{\partial H_{c_{i}}}{\partial \zeta}\left(x_{i}(t), y_{i}(t)\right)<br>$</p><p>In this work, the offsets $c_{x, i}, c_{y, i}$ will be used to achieve body control during the locomotion of the robot while preserving the step heights and forward speed. More specifically, the $c_y$ is adapted to achieve body posture control by updating the vertical control of the robot’s shoulder, and the $c_{x}$ is only set initially to adjust the spread of the legs. Note that the limit cycle only translates in the joint space of the associated leg, meaning that the limit cycle’s shape and scale stay the same.</p><h1 id="Inertial-Posture-Control"><a href="#Inertial-Posture-Control" class="headerlink" title="Inertial Posture Control"></a>Inertial Posture Control</h1><p>This section introduces the approach to body posture control, which adapts the limit cycle of each leg at each time step, based on inertial feedback. We first present our method for computing the end-effector error, such that correcting the body will have achieved the desired orientation. Then we detail the approach to adapting the vertical CPG offsets from the end-effector error.</p><h2 id="A-Computing-CPG-Offsets-Using-end-effector-Error"><a href="#A-Computing-CPG-Offsets-Using-end-effector-Error" class="headerlink" title="A.Computing CPG Offsets Using end-effector Error"></a>A.Computing CPG Offsets Using end-effector Error</h2><p>In this part, we try to make the attitude level, so we rotate the robot and use inverse kinematics to change the joint space trajectory.<br><img src="/images/hexo/hexo_robot.png" alt></p><p>Denote $e=\tilde{r}-r$. With discrete kinematics equation, we can get:</p><script type="math/tex; mode=display">\frac{e}{\Delta t}=J*\frac{\Delta\theta_e}{\Delta t}\tag{6}</script><h2 id="B-Adaptation-of-CPG-Parameters-for-Body-Posture-Control"><a href="#B-Adaptation-of-CPG-Parameters-for-Body-Posture-Control" class="headerlink" title="B.Adaptation of CPG Parameters for Body Posture Control"></a>B.Adaptation of CPG Parameters for Body Posture Control</h2><p>The figure of hexapod leg configuration is as followed:<br><img src="/images/hexo/leg_config.png" alt></p><p>So the first row of $\Delta \theta_e$ is of interest, as they influence $c_x$ and $c_y$. Since the body control aims at keeping the attitude level instead of changing the robot heading direction, the first row of $\Delta \theta_e$  should be 0. By contrast, the second row of $\Delta \theta_e$  should be integrated with time to change $c_y(t)$:</p><script type="math/tex; mode=display">c_{y}(t)=c_{y_{0}}+\int_{0}^{t} \Delta \theta_{e}(t) d t\tag{7}</script><p>We additionally incorporate the change inro CPG Eq.(5), which finally read:</p><script type="math/tex; mode=display">\left\{\begin{aligned}\dot{x_{i}}(t)=&-\omega \cdot \partial H_{y_{i}}+\gamma\left(1-H_{c_{i}(t)}\left(x_{i}(t), y_{i}(t)\right)\right) \cdot \partial H_{x_{i}} \\\dot{y_{i}}(t)=&+\omega \cdot \partial H_{x_{i}}+\gamma\left(1-H_{c_{i}(t)}\left(x_{i}(t), y_{i}(t)\right)\right) \cdot \partial H_{y_{i}} \\&+\left(\lambda \sum_{j} K_{i j}\left(y_{j}(t)-c_{y, j}\right)+\Delta \theta_{e_{2, i}}(t)\right.\end{aligned}\right.\tag{8}</script><h1 id="Hardware-Experiments"><a href="#Hardware-Experiments" class="headerlink" title="Hardware Experiments"></a>Hardware Experiments</h1><p>Joints angles are set based on the CPG outputs as follows:</p><script type="math/tex; mode=display">\left\{\begin{aligned}\theta_{1, i} &=x_{i} \\\theta_{2, i} &=\max \left(y_{i}, c_{y, i}\right) \\\theta_{3, i} &=f\left(\theta_{1, i}, \theta_{2, i}\right)\end{aligned}\right.\tag{9}</script><p>The proximal joint takes the x-output. And for the intermediate joint, we assume that $y_i&lt;c_{y, i}$ defines the legs are on the ground, so we use a max function to maintain a constant body height throughout the stance phase. For the distal joint, the inverse kinematic function is used to make the end-effectors remain at a constant, desired distance from the body.</p><h1 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h1><p>Inertial-based body control improves locomotive performance in two ways, which are the increase in locomotion speed and adapting to more extreme slopes. Locomotive performance increases for several reasons:</p><ol><li>Leveling the body reduces the load on the lateral, proximal joints that are responsible for propelling the body forward.</li><li>Make the CoG more centrally within the support polygon formed by grounded legs.</li><li>This body orientation prevents the robot from tipping while stepping on or off an obstacle.</li></ol><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>This paper integrates body posture as a feedback signal within the CPG framework. Use the attitude angle as the error to modulate the CPG limit cycle in order to make the body posture level. They use a Hopf-based model with changes in the shape of the limit cycle (superellipse) and offsets.</p>]]></content>
      
      
      
        <tags>
            
            <tag> CPG </tag>
            
            <tag> legged_robot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpg_Biped</title>
      <link href="/2022/09/12/cpg-biped/"/>
      <url>/2022/09/12/cpg-biped/</url>
      
        <content type="html"><![CDATA[<blockquote><p>reference: Central pattern generator inspired control for adaptive walking of biped robots</p></blockquote><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>This paper deals with the adaptive walking control of biped robots. Use CPGs to generate CoG trajectory and a workspace trajectory modulation process. Also, the generator can use feedback to modulate CoG trajectories and workspace trajectories. A motion engine maps trajectories from workspace to joint space. We use the NAO platform to confirm the effectiveness of the proposed control strategy.</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>The main contributions of this paper:</p><ol><li>A CoG trajectory generation method is proposed based on CPGs, A mapping function is designed to map the output signals of CPGs to 3-D CoG trajectories online for a biped robot.</li><li>A workspace trajectory modulator is designed based on CoG trajectories. The generated CoG trajectories are used to modulate the workspace trajectories to realize adaptive walking.</li><li>Through the mutual entrainment of CPGs with the feedback signals of the robot, the adaptive CoG trajectories and workspace trajectories can be generated online.</li><li>The proposed control strategy is validated using the biped robot NAO.</li></ol><h1 id="Control-Architecture"><a href="#Control-Architecture" class="headerlink" title="Control Architecture"></a>Control Architecture</h1><p><img src="/images/control.png" alt><br>The control system architecture consists of a trajectory generator and a motion engine. The paper uses feedback information along with function mapping to generate CoG trajectory. Then the CoG output can modulate the workspace generator. And finally, the workspace trajectory can generate the joint signals.</p><h1 id="CPG-Inspired-Trajectory-Generator"><a href="#CPG-Inspired-Trajectory-Generator" class="headerlink" title="CPG-Inspired Trajectory Generator"></a>CPG-Inspired Trajectory Generator</h1><p>The mapping function is designed to transform the output of the CPGs to CoG trajectories. The amplitude and period of CoG trajectories can modulate the workspace trajectories. The objectives of the trajectories are as followed:</p><ol><li>Generation of CoG</li><li>Generation of workspace trajectories</li><li>Entraining with feedback information</li></ol><h2 id="A-CoG-Trajectory-Generation"><a href="#A-CoG-Trajectory-Generation" class="headerlink" title="A.CoG Trajectory Generation"></a>A.CoG Trajectory Generation</h2><p>1) CPG Model<br>In this paper, Kimura’s oscillator is modified and used as a CPG medel<br>$$\begin{aligned}T_{r} \dot{u}_{i}^{\{e, f\}}=&-u_{i}^{\{e, f\}}-w_{f e} r_{i}^{\{f, e\}}-\beta v_{i}^{\{e, f\}}+s_{0} \\&+\sum_{j=1}^{n} w_{i j} r_{j}^{\{e, f\}}+f e e d_{i}^{\{e, f\}} \\T_{a} \dot{v}_{i}^{\{e, f\}}=&-v_{i}^{\{e, f\}}+r_{i}^{\{e, f\}} \\r_{i}^{\{e, f\}}=& \max \left(u_{i}^{\{e, f\}}, 0\right) \\r_{i} &=-u_{i}^{\{e\}}+u_{i}^{\{f\}}\end{aligned} $$2) Mapping Function Design$$\begin{array}{l}\mathrm{CoG}_{x}=o f f_{x}+K_{x}\left(r_{1}+f(t)\right) \\\mathrm{CoG}_{y}=o f f_{y}+K_{y} r_{2} \\\mathrm{CoG}_{z}=o f f_{z}+K_{z} r_{3}\end{array}$$<br>where off are offsets, K are translation gains, and r are output signals of the CPG units, f(t) is the basic ramp function.</p><h2 id="B-Workspace-Trajectory-Modulation"><a href="#B-Workspace-Trajectory-Modulation" class="headerlink" title="B.Workspace Trajectory Modulation"></a>B.Workspace Trajectory Modulation</h2><p>The trajectory of the swingfoot, as shown following, is generated by a rolling circle, which is represented by</p><script type="math/tex; mode=display">\begin{array}{l}p_{x}=a(\theta-\sin \theta) \\p_{z}=a(1-\cos \theta)\end{array}</script><p><img src="/images/circle.png" alt><br>The position of each toe on the predesigned workspace trajectory is given as functions the the state of the CoG trajectory as follows:</p><script type="math/tex; mode=display">\left\{\begin{aligned}x_{\text {locus }}(i)=& A m p_{\mathrm{CoG}_{\mathrm{x}}}(i)\times\left(\frac{2 \pi \cdot t_{s(\text { index })}}{t_{s}}-\sin \left(2 \pi \cdot t_{s(\text { index })} / t_{s}\right)\right) \\z_{\text {locus }}(i)=& A m p_{\operatorname{CoG}_{\mathrm{x}}}(i) \times\left(1-\cos \left(2 \pi \cdot t_{s(\text { index })} / t_{s}\right)\right)\end{aligned}\right.</script><p>Where $Amp_{Cog}$ is the step length(<em>in my view, it is the _height of _the _step__, but_ the paper says the step length</em>).$t_s$ is the during of the swing phase. With the following pictures, we can understand more clearly.</p><p><img src="/images/CoG.png" alt><br><img src="/images/y.png" alt><br>Thus, through the modulation of the amplitude, $Amp_{CoG}$, the cyclic periods $t_c$ and the parameter $r_d$, we can modulate the step height, step length and duration periods of swinging and supporting phases.</p><blockquote><p>This paper uses the attitude angle as feed back to make the robot walk on a slope.</p></blockquote><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>This paper uses CPGs(Kimura model) to generate a reference CoG trajectory and then modulates the foot trajectory and finally generates the joint trajectory.<br>In short, this paper uses CPG to generate foot trajectory and the role of feedback is to modulate step length and step height.</p>]]></content>
      
      
      
        <tags>
            
            <tag> CPG </tag>
            
            <tag> legged_robot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello_world</title>
      <link href="/2022/09/11/hello-world/"/>
      <url>/2022/09/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>first blog with hexo + github</p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello_world </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
